#!/bin/bash
# Kubeconfig Manager Script
# A robust tool to manage multiple Kubernetes kubeconfig files with fzf integration
set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
KUBE_DIR="$HOME/.kube"
CONFIG_FILE="$KUBE_DIR/config"
BACKUP_DIR="$KUBE_DIR/backups"
MAX_BACKUPS=5

# Ensure directories exist
mkdir -p "$BACKUP_DIR"

# Function to print colored output
print_color() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Function to print success message
print_success() {
    print_color $GREEN "✅ $1"
}

# Function to print error message
print_error() {
    print_color $RED "❌ $1"
}

# Function to print info message
print_info() {
    print_color $BLUE "ℹ️  $1"
}

# Function to print warning message
print_warning() {
    print_color $YELLOW "⚠️  $1"
}

# Function to show help
show_help() {
    echo -e "${CYAN}Kubeconfig Manager - A robust tool to manage Kubernetes kubeconfig files${NC}"
    echo ""
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help              Show this help message"
    echo "  -a, --add <name>        Create a new kubeconfig file with vim"
    echo "  -l, --list              List all available kubeconfig files"
    echo "  -b, --backup            Create backup of current config"
    echo "  -r, --restore <file>    Restore config from backup"
    echo "  -v, --validate <file>   Validate a kubeconfig file"
    echo "  -c, --current           Show current kubeconfig context"
    echo "      --init              Install required dependencies"
    echo ""
    echo "Examples:"
    echo "  $0                      Interactive mode: select kubeconfig with fzf"
    echo "  $0 -a my-cluster        Create new kubeconfig file named my-cluster"
    echo "  $0 -l                   List all available kubeconfig files"
    echo "  $0 -b                   Create backup of current config"
    echo "  $0 -r config.backup.20231201  Restore from backup"
    echo "  $0 --init               Install required dependencies"
    echo ""
    echo "Features:"
    echo "  • Interactive selection with fzf"
    echo "  • Manual backup creation (disabled by default)"
    echo "  • Config file validation"
    echo "  • Beautiful colored output"
    echo "  • Error handling and validation"
    echo "  • Support for multiple file extensions (.yaml, .yml, .config, .dev, .qa, .prod, .txt)"
    echo "  • Dependency installation with --init"
}

# Function to validate kubeconfig file
validate_kubeconfig() {
    local file=$1
    if [[ ! -f "$file" ]]; then
        print_error "File not found: $file"
        return 1
    fi
    
    # Check if it's a valid YAML file
    if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
        print_error "Invalid YAML format in: $file"
        return 1
    fi
    
    # Check if it has required kubeconfig fields
    if ! grep -q "apiVersion: v1" "$file" || ! grep -q "kind: Config" "$file"; then
        print_error "Not a valid kubeconfig file: $file"
        return 1
    fi
    
    return 0
}

# Function to create backup
create_backup() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        print_warning "No config file to backup"
        return 1
    fi
    
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local backup_file="$BACKUP_DIR/config.backup.$timestamp"
    
    cp "$CONFIG_FILE" "$backup_file"
    print_success "Backup created: $backup_file"
    
    # Clean old backups
    cd "$BACKUP_DIR"
    ls -t config.backup.* | tail -n +$((MAX_BACKUPS + 1)) | xargs rm -f 2>/dev/null || true
    print_info "Cleaned old backups, keeping last $MAX_BACKUPS"
}

# Function to list available kubeconfig files
list_configs() {
    print_info "Available kubeconfig files in $KUBE_DIR:"
    echo ""
    
    local configs=()
    while IFS= read -r -d $'\0' file; do
        configs+=("$file")
    done < <(find "$KUBE_DIR" -maxdepth 1 -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.config" -o -name "*.dev" -o -name "*.qa" -o -name "*.prod" -o -name "*.txt" \) -print0 | sort -z)
    
    if [[ ${#configs[@]} -eq 0 ]]; then
        print_warning "No kubeconfig files found"
        return 1
    fi
    
    for config in "${configs[@]}"; do
        local basename=$(basename "$config")
        if [[ "$config" == "$CONFIG_FILE" ]]; then
            print_color $GREEN "  → $basename (active)"
        else
            echo "  • $basename"
        fi
    done
    
    echo ""
    print_info "Total: ${#configs[@]} config files"
}

# Function to show current context
show_current_context() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        print_error "No kubeconfig file found at $CONFIG_FILE"
        return 1
    fi
    
    local current_context=$(kubectl config current-context 2>/dev/null || echo "No context set")
    local current_cluster=$(kubectl config get-contexts --no-headers | grep "^\*" | awk '{print $3}' || echo "No cluster")
    
    print_info "Current kubeconfig information:"
    echo ""
    echo "  Context:  $current_context"
    echo "  Cluster:  $current_cluster"
    echo "  Config:   $CONFIG_FILE"
}

# Function to restore from backup
restore_backup() {
    local backup_file=$1
    
    if [[ -z "$backup_file" ]]; then
        print_error "Please specify a backup file to restore"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        # Try to find it in backup directory
        backup_file="$BACKUP_DIR/$backup_file"
        if [[ ! -f "$backup_file" ]]; then
            print_error "Backup file not found: $backup_file"
            return 1
        fi
    fi
    
    # Create backup before restore - DISABLED
    # create_backup
    
    cp "$backup_file" "$CONFIG_FILE"
    print_success "Restored config from: $backup_file"
    show_current_context
}

# Function to add new kubeconfig file
add_config() {
    local name=$1
    
    if [[ -z "$name" ]]; then
        print_error "Please provide a name for the new config file"
        return 1
    fi
    
    # Determine file extension
    local extension=""
    if [[ "$name" == *.yaml ]] || [[ "$name" == *.yml ]] || [[ "$name" == *.config ]] || [[ "$name" == *.dev ]] || [[ "$name" == *.qa ]] || [[ "$name" == *.prod ]] || [[ "$name" == *.txt ]]; then
        extension=""
    else
        extension=".yaml"
    fi
    
    local config_file="$KUBE_DIR/${name}${extension}"
    
    if [[ -f "$config_file" ]]; then
        print_warning "File already exists: $config_file"
        read -p "Overwrite? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Operation cancelled"
            return 0
        fi
    fi
    
    # Create a temporary file with the template
    local temp_file=$(mktemp)
    
    # Create template in temporary file
    cat > "$temp_file" << EOF
apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: 
    server: 
  name: 
contexts:
- context:
    cluster: 
    namespace: 
    user: 
  name: 
current-context: 
preferences: {}
users:
- name: 
  user:
    client-certificate-data: 
    client-key-data: 
EOF
    
    # Calculate checksum of the original template
    local original_checksum=$(md5sum "$temp_file" | awk '{print $1}')
    
    # Open temporary file in vim
    vim "$temp_file"
    
    # Calculate checksum after editing
    local new_checksum=$(md5sum "$temp_file" | awk '{print $1}')
    
    # Check if the file was modified
    if [[ "$original_checksum" != "$new_checksum" ]]; then
        # File was modified, copy to final location
        cp "$temp_file" "$config_file"
        
        # Validate after editing
        if validate_kubeconfig "$config_file"; then
            print_success "New kubeconfig file created: $config_file"
            print_info "You can now select it using: $0"
        else
            print_error "Invalid kubeconfig file created"
            read -p "Keep the file anyway? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                rm -f "$config_file"
                print_info "File deleted"
            fi
        fi
    else
        print_info "No changes made, file not created"
    fi
    
    # Clean up temporary file
    rm -f "$temp_file"
}

# Function to install dependencies
init_dependencies() {
    print_info "Installing required dependencies..."
    
    # Detect the package manager
    if command -v apt-get &> /dev/null; then
        PACKAGE_MANAGER="apt-get"
        UPDATE_CMD="sudo apt-get update"
        INSTALL_CMD="sudo apt-get install -y"
    elif command -v yum &> /dev/null; then
        PACKAGE_MANAGER="yum"
        UPDATE_CMD="sudo yum update -y"
        INSTALL_CMD="sudo yum install -y"
    elif command -v brew &> /dev/null; then
        PACKAGE_MANAGER="brew"
        UPDATE_CMD="brew update"
        INSTALL_CMD="brew install"
    else
        print_error "No supported package manager found. Please install dependencies manually."
        exit 1
    fi
    
    print_info "Using package manager: $PACKAGE_MANAGER"
    
    # Update package lists
    print_info "Updating package lists..."
    if [[ $PACKAGE_MANAGER == "brew" ]]; then
        $UPDATE_CMD
    else
        $UPDATE_CMD > /dev/null 2>&1
    fi
    
    # Install fzf if not installed
    if ! command -v fzf &> /dev/null; then
        print_info "Installing fzf..."
        if [[ $PACKAGE_MANAGER == "brew" ]]; then
            $INSTALL_CMD fzf
        else
            # For Linux systems, we'll use the git repository method
            git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
            ~/.fzf/install --all --key-bindings --completion --update-rc
        fi
        print_success "fzf installed successfully"
    else
        print_info "fzf is already installed"
    fi
    
    # Install vim if not installed
    if ! command -v vim &> /dev/null; then
        print_info "Installing vim..."
        $INSTALL_CMD vim
        print_success "vim installed successfully"
    else
        print_info "vim is already installed"
    fi
    
    # Install kubectl if not installed
    if ! command -v kubectl &> /dev/null; then
        print_info "Installing kubectl..."
        if [[ $PACKAGE_MANAGER == "brew" ]]; then
            $INSTALL_CMD kubectl
        else
            # For Linux systems
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
            rm -f kubectl
        fi
        print_success "kubectl installed successfully"
    else
        print_info "kubectl is already installed"
    fi
    
    # Install python3-yaml if not available (for YAML validation)
    if ! python3 -c "import yaml" &> /dev/null; then
        print_info "Installing python3-yaml..."
        if [[ $PACKAGE_MANAGER == "apt-get" ]]; then
            $INSTALL_CMD python3-yaml
        elif [[ $PACKAGE_MANAGER == "yum" ]]; then
            $INSTALL_CMD python3-PyYAML
        elif [[ $PACKAGE_MANAGER == "brew" ]]; then
            $INSTALL_CMD python-yaml
        fi
        print_success "python3-yaml installed successfully"
    else
        print_info "python3-yaml is already available"
    fi
    
    print_success "All dependencies installed successfully!"
    print_info "You can now use the kubeconfig manager script."
}

# Function to select and switch kubeconfig using fzf
select_and_switch() {
    # Find all kubeconfig files with all supported extensions
    local configs=()
    local config_names=()
    
    while IFS= read -r -d $'\0' file; do
        # Skip the main config file
        if [[ "$file" != "$CONFIG_FILE" ]]; then
            configs+=("$file")
            config_names+=("$(basename "$file")")
        fi
    done < <(find "$KUBE_DIR" -maxdepth 1 -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.config" -o -name "*.dev" -o -name "*.qa" -o -name "*.prod" -o -name "*.txt" \) -print0 | sort -z)
    
    if [[ ${#configs[@]} -eq 0 ]]; then
        print_error "No kubeconfig files found in $KUBE_DIR"
        print_info "Use '$0 -a <name>' to create a new config file"
        return 1
    fi
    
    # Use fzf for selection with filenames only
    print_info "Select a kubeconfig file:"
    local selected_name
    selected_name=$(printf "%s\n" "${config_names[@]}" | fzf --height=15 --prompt="Select kubeconfig > " --preview="echo \"File: \$(echo {} | sed \"s/'//g\")\"; echo \"\"; head -30 \"$KUBE_DIR/\$(echo {} | sed \"s/'//g\")\"" --preview-window=right:50%)
    
    if [[ -z "$selected_name" ]]; then
        print_info "No selection made"
        return 0
    fi
    
    # Remove quotes from selected name
    selected_name=$(echo "$selected_name" | sed "s/'//g")
    
    # Find the full path from the selected name
    local selected_file=""
    for i in "${!config_names[@]}"; do
        if [[ "${config_names[$i]}" == "$selected_name" ]]; then
            selected_file="${configs[$i]}"
            break
        fi
    done
    
    # Validate selected file
    if ! validate_kubeconfig "$selected_file"; then
        print_error "Invalid kubeconfig file: $selected_file"
        return 1
    fi
    
    # Create backup before switching - DISABLED
    # create_backup
    
    # Copy selected file to config
    cp "$selected_file" "$CONFIG_FILE"
    
    print_success "Switched to kubeconfig: $selected_name"
    
    # Show current context
    show_current_context
}

# Main script logic
main() {
    # Check if fzf is installed
    if ! command -v fzf &> /dev/null; then
        print_error "fzf is not installed."
        echo "  Try './clusters.sh --init' to install dependencies"
        exit 1
    fi
    
    # Check if vim is installed
    if ! command -v vim &> /dev/null; then
        print_error "vim is not installed."
        echo "  Try './clusters.sh --init' to install dependencies"
        exit 1
    fi
    
    # Check if kubectl is installed
    if ! command -v kubectl &> /dev/null; then
        print_warning "kubectl is not installed. Some features may not work."
        echo "  Try './clusters.sh --init' to install dependencies"
    fi
    
    # Check if python3-yaml is available
    if ! python3 -c "import yaml" &> /dev/null; then
        print_warning "python3-yaml is not available. Some features may not work."
        echo "  Try './clusters.sh --init' to install dependencies"
    fi
    
    # Parse arguments
    case "${1:-}" in
        -h|--help)
            show_help
            ;;
        -a|--add)
            add_config "$2"
            ;;
        -l|--list)
            list_configs
            ;;
        -b|--backup)
            create_backup
            ;;
        -r|--restore)
            restore_backup "$2"
            ;;
        -v|--validate)
            validate_kubeconfig "$2"
            ;;
        -c|--current)
            show_current_context
            ;;
        --init)
            init_dependencies
            ;;
        "")
            select_and_switch
            ;;
        *)
            print_error "Unknown option: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function
main "$@"